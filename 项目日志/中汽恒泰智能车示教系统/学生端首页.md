---
title: 学生端首页
tags: 新建,模板,小书匠
renderNumberedHeading: true
grammar_cjkRuby: true
---

### 概述
1. 检查课程是否在线，访问[学生进入课堂检验](http://192.168.10.106:8080/project/3?p=156)接口
2. 访问[student_get_vehicle_info](http://192.168.10.106:8080/project/3?p=157)接口，检查车辆是否在线，车辆状态（损毁、离线、被占用），并获取[车辆信息](http://192.168.10.106:8080/project/3?p=157)
3. 若车辆未被占用，则访问[车辆绑定接口](http://192.168.10.106:8080/project/3?p=158)，绑定车辆
4. 访问[考勤接口](http://192.168.10.106:8080/project/3?p=159)，进行自动考勤，
5. 开启[车辆服务](http://192.168.10.106:8080/project/3?p=297)，实时更新车辆信息
6. 在左侧，显示车辆编号、档位、速度、剩余电量、电压、电流等信息（调用[车辆服务](http://192.168.10.106:8080/project/3?p=297)口，每隔0.1秒刷新一次）


### 具体逻辑
学生端首页的处理过程处于一个学生端主逻辑循环中。

``` py
# ui/student.py
def show_ui_and_always_check_if_waiting(self):
        ... ...
```
主逻辑循环中的核心代码如下：
1. 检查课程是否在线，访问[学生进入课堂检验](http://192.168.10.106:8080/project/3?p=156)接口
	``` py
	 # 检查该时间段所学课程是否在线
				state, response = self.check_class_online()
				if not state or not response['state']:
					# 课程不在线
					self.waiting_dialog.set_formatted_text(response['info']['detail'])
					self.waiting_dialog.show()
					time.sleep(1)
					continue
				# 课程在线，若不存在，记录课程信息,
				if not self.course_info:
					self.course_info = response['info']
	```
1. 访问[student_get_vehicle_info](http://192.168.10.106:8080/project/3?p=157)接口，检查车辆是否在线，车辆状态（损毁、离线、被占用），并获取[车辆信息](http://192.168.10.106:8080/project/3?p=157)
	``` py
	# 检查对应车辆是否已经在线
				state, response = self.get_vehicle_info()
				#
				if not state or not response['state']:
					# 车辆不在线
					self.waiting_dialog.set_formatted_text(response['info']['detail'])
					self.waiting_dialog.show()
					time.sleep(1)
					continue
				# 车辆损毁
				if response['info']['status'] == 'damaged':
					self.waiting_dialog.set_formatted_text('{id}号车辆损坏，请寻求老师帮助'.format(id=response['info']['id']))
					self.waiting_dialog.show()
					time.sleep(1)
					continue
				# 车辆离线
				if response['info']['status'] == 'offline':
					self.waiting_dialog.set_formatted_text('{id}号车辆尚未启动，请等待'.format(id=response['info']['id']))
					self.waiting_dialog.show()
					continue
				# 车辆被占用
				if not self.is_bind_vehicle and response['info']['status'] == 'bind':
					self.waiting_dialog.set_formatted_text('{id}号车辆已经被他人占用，请寻求老师帮助'.format(id=response['info']['id']))
					self.waiting_dialog.show()
					continue
				# 云端变更车辆信息，绑定车辆
				# 获取车辆信息
				self.vehicle_info = response['info']
	```
3. 若车辆未被占用，则访问[车辆绑定接口](http://192.168.10.106:8080/project/3?p=158)，绑定车辆
	``` py
	# 根据车辆信息进行绑定
				if not self.is_bind_vehicle:
					# 未绑定则绑定
					self.bind_vehicle()
				# 确认绑定状态
				self.is_bind_vehicle = True
	```
4. 访问[考勤接口](http://192.168.10.106:8080/project/3?p=159)，进行自动考
	``` py
	# 一切准备就绪
				# 开始自动考勤

				if not self.is_check_on_work_attendance:
					# 若未进行考勤
					# state, response = self.check_on_work_attendance()
					self.check_on_work_attendance()
					# 更新登出时间
					self.logout_time = datetime_now()
					# 显示考勤信息
					self.waiting_dialog.set_formatted_text('自动考勤中...,登录时间为：{}'.format(
						time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
					))
					self.is_check_on_work_attendance = True
	```
5. 开启[车辆服务](http://192.168.10.106:8080/project/3?p=297)，实时更新车辆信息
	``` py
	# 开启车辆服务
					start_thread_work(self.start_vehicle_service)
	```
6. 在左侧，显示车辆编号、档位、速度、剩余电量、电压、电流等信息（调用[车辆服务](http://192.168.10.106:8080/project/3?p=297)口，每隔0.1秒刷新一次）
	``` py
	# 开启ui更新服务
					start_thread_work(self.update_ui_vehicle_data_service)
	```

可以看到，在通过所有检查之后，主逻辑循环开启了两个线程，用于开启车辆服务与ui更新服务。

``` py
# 开启车辆服务
start_thread_work(self.start_vehicle_service)
# 开启ui更新服务
start_thread_work(self.update_ui_vehicle_data_service)
```
`self.start_vehicle_service`代码如下：

``` py
# ui/student.py
def start_vehicle_service(self):
        # 通知车端服务提起roscore
        vehicle_communication.send({'action': 'car_sys_start'})
        self.vehicle_node_service.start_vehicle_node.set()
```
可以看到，其访问了[car_sys_start](http://192.168.10.106:8080/project/3?p=197)接口，调起了车端ros服务。同时开启了[车辆数据服务](http://192.168.10.106:8080/project/3?p=297)

`update_ui_vehicle_data_service`函数代码如下：
``` py
# ui/student.py
    def update_ui_vehicle_data_service(self):
        # ui界面更新服务
        while True:
            time.sleep(0.1)
            if self.vehicle_node_service is None:
                time.sleep(1)
                continue
            self.signal_update_ui_vehicle_data.emit()
```