---
title: 控制端通讯接口使用方法与规范
tags: 新建,模板,小书匠
renderNumberedHeading: true
grammar_cjkRuby: true
---


通讯模块处于`app/communication/`文件夹下，是系统之间进行`socket`通讯的顶层接口。
在需要进行各个系统之间的通讯时，直接导入`app/communication/communication.py`中的单例而不是导入此文件中的`Communication`类进行实例化。
例如，在进行控制端与数据库服务端通讯时：
- 使用：
	``` python
	from app.communication.communication import server_communication
	server_communication.communicate({
		'action':'test',
		'info':dict()
	})
	```
- 不要使用：
	``` python
	from app.communication.communication import Communication
	server_communication = Communication('server_communication.json')
	server_communication.communicate({
		'action':'test',
		'info':dict()
	})
	```
同时，如果存在需要实例化`Communication`类的需求，直接在`app/communication/communication.py`文件中，参考已经实例化的单例进行类的实例化，一般情况下，只允许在同一地址的同一端口进行一次`Communication`类的实例化，以免出现通讯冗余和回调误动作（这是一条标准，而不是语法强制）。
`Communication`类当前暴露给调用者三个函数接口，分别为：
- `send(dict request,callable callback=nop)`：异步通讯，非阻塞
- `bool state,dict result communicate(dict request,float timeout)`：同步通讯，超时时间内阻塞
- `bool state register_global_callback(str name,callable callback)`：注册全局回调

这里的代码为伪代码，对应关系为：`返回值类型 返回值1，返回值类型 返回值2 ... 函数名（参数类型 参数1、参数类型 参数2、...）`

### 函数接口
##### send

``` py
send(dict request,callable callback=nop)
```
此函数无返回值，是控制端进行异步远程通讯的顶层接口，此函数接受两个参数
- `request`：字典类型，是控制端发送给远程目标的请求包。此请求包一般应包含**两个键值对**
	- `action`：字符串，动作名
	- `info`：字典类型，动作信息
	例如：
	``` py
	{
		'action': 'admin_get_vehicle_current_running_data',
		'info': {
			'vehicle_id': 1
		}
	}
	```
- `callback`：可执行的函数，是控制端收到远程目标响应后执行的函数，此函数需要有且仅有一个必须的参数用来接收远程目标发送回来的响应。
	例如：
	``` py
	def callback(response, kwarg='now'):
		if 'action' in response and response['action'] == 'admin_get_vehicle_current_running_data':
			print 'success' + kwarg
	```
使用示例

``` py
import time
from app.communication.communication import server_communication


def callback(response, kwarg='now'):
    if 'action' in response and response['action'] == 'admin_get_vehicle_current_running_data':
        print 'success' + kwarg
    pass


request = {
    'action': 'admin_get_vehicle_current_running_data',
    'info': {
        'vehicle_id': 2
    }
}
server_communication.send(request, callback)
while True:
    print 'mainloop'
    time.sleep(1)
```

`send`函数的流程图如下：
```flow!
st=>start: send(request,callback)
e=>end: 结束
op0=>operation: 开启非阻塞服务线程
op1=>operation: 记录错误信息
op2=>operation: 注册回调
op=>operation: 在
cond=>condition: 成功?
st->op0->cond
cond(no)->op1->e
cond(yes)->e
```
非阻塞服务线程的流程图如下
```flow!
st=>start: 开始
e=>end: 结束
op0=>operation: 生成签名，打包入request
op1=>operation: 使用签名，注册回调函数
op2=>operation: 等待远程响应
op3=>operation: 传入响应信息，调用回调函数
op=>operation: 在
cond=>condition: 签名是否正确？
st->op0->op1->op2->cond
cond(no)->op2
cond(yes)->op3->e
```
##### communicate
``` py
bool state,dict result communicate(dict request,float timeout)
```
此函数接受两个参数
- `request`：字典类型，是控制端发送给远程目标的请求包。此请求包一般应包含**两个键值对**
	- `action`：字符串，动作名
	- `info`：字典类型，动作信息
	例如：
	``` py
	{
		'action': 'admin_get_vehicle_current_running_data',
		'info': {
			'vehicle_id': 1
		}
	}
	```
- `timeout`：超时时间

此函数返回两个值
- `state`：通讯的状态，若通讯超时则返回`False`，只要通讯成功就返回`True`
- `result`：通讯目标返回的响应包

示例：

``` py
from app.communication.communication import server_communication

request = {
    'action': 'admin_get_vehicle_current_running_data',
    'info': {
        'vehicle_id': 2
    }
}
state, result = server_communication.communicate(request)
print state, result
print 'mainloop'
```

`communicate`函数的流程图如下
```flow!
st=>start: 开始
e=>end: 结束
op0=>operation: 生成签名，打包request
op1=>operation: 发送请求
op2=>operation: 等待0.1秒
op3=>operation: 转发响应
op4=>operation: 返回结果
op=>operation: 在
cond1=>condition: 是否存在响应？
cond2=>condition: 是否超时？
cond3=>condition: 签名是否正确？
st->op0->op1->cond1
cond1(no)->op2->cond2
cond2(no)->cond1
cond2(yes)->op4

cond1(yes)->cond3
cond3(no)->cond1
cond3(yes)->op4

op4->e
```
注意，当签名不正确的时候会有一个转发过程。

##### register_global_callback

``` py
bool state register_global_callback(str name,callable callback)
```
此函数接受两个参数
- `name`：字符串，全局回调名
- `callback`：全局回调函数

此函数返回一个值
- `state`：是否注册成功，失败则返回`False`，成功就返回`True`

全局回调的注册流程如下：

```flow!
st=>start: 开始
e=>end: 结束
op0=>operation: 注册回调
op1=>operation: 记录错误信息
op2=>operation: 注册回调
op3=>operation: 返回False
op3=>operation: 返回True
cond=>condition: 是否存在同名回调?
st->op0->cond
cond(yes)->op1->e
cond(no)->e
```