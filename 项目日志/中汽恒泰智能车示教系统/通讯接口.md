---
title: 控制端通讯接口使用方法与规范
tags: 新建,模板,小书匠
renderNumberedHeading: true
grammar_cjkRuby: true
---


通讯模块处于`app/communication/`文件夹下，是系统之间进行`socket`通讯的顶层接口。
在需要进行各个系统之间的通讯时，直接导入`app/communication/communication.py`中的单例而不是导入此文件中的`Communication`类进行实例化。
例如，在进行控制端与数据库服务端通讯时：
- 使用：
	``` python
	from app.communication.communication import server_communication
	server_communication.communicate({
		'action':'test',
		'info':dict()
	})
	```
- 不要使用：
	``` python
	from app.communication.communication import Communication
	server_communication = Communication('server_communication.json')
	server_communication.communicate({
		'action':'test',
		'info':dict()
	})
	```
同时，如果存在需要实例化`Communication`类的需求，直接在`app/communication/communication.py`文件中，参考已经实例化的单例进行类的实例化，一般情况下，只允许在同一地址的同一端口进行一次`Communication`类的实例化，以免出现通讯冗余和回调误动作（这是一条标准，而不是语法强制）。
`Communication`类当前暴露给调用者三个函数接口，分别为：
- `send(dict request,callable callback=nop)`：异步通讯，非阻塞
- `bool state,dict result communicate(dict request,float time)`：同步通讯，超时时间内阻塞
- `bool state register_global_callback(str name,callable callback)`：注册全局回调
以上代码为伪代码，对应关系为：`返回值类型 返回值1，返回值类型 返回值2 ... 函数名（参数类型 参数1、参数类型 参数2、...）`

### 函数接口
##### send

``` py
send(dict request,callable callback=nop)
```
此函数无返回值，是控制端进行异步远程通讯的顶层接口，此函数接受两个参数
- `request`：字典类型，是控制端发送给远程目标的请求包。此请求包一般应包含**两个键值对**
	- `action`：字符串，动作名
	- `info`：字典类型，动作信息
	例如：
	``` py
	{
		'action': 'admin_get_vehicle_current_running_data',
		'info': {
			'vehicle_id': 1
		}
	}
	```
- `callback`：可执行的函数，是控制端收到远程目标响应后执行的函数，此函数需要有且仅有一个必须的参数用来接收远程目标发送回来的响应。
	例如：
	``` py
	def callback(response, kwarg='now'):
		if 'action' in response and response['action'] == 'admin_get_vehicle_current_running_data':
			print 'success' + kwarg
	```
`send`函数的流程图如下：
```flow!
st=>start: send(request,callback)
e=>end: 结束
op0=>operation: 开启非阻塞服务线程
op1=>operation: 记录错误信息
op2=>operation: 注册回调
op=>operation: 在
cond=>condition: 成功?
st->op0->cond
cond(no)->op1->e
cond(yes)->e
```
非阻塞服务线程的流程图如下
```flow!
st=>start: 开始
e=>end: 结束
op0=>operation: 生成签名，打包request
op1=>operation: 使用签名，注册回调函数
op2=>operation: 注册回调
op=>operation: 在
cond=>condition: 成功?
st->op0->cond
cond(no)->op1->e
cond(yes)->e
```