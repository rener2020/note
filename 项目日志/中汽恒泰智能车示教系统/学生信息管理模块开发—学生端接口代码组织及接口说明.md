---
title: 学生信息管理模块开发—学生端接口代码组织及接口说明
tags: 新建,模板,小书匠
renderNumberedHeading: true
grammar_cjkRuby: true
---


# 通讯接口
面向服务端的访问请求使用三个服务组件：
- 使用`Queue.Queue`进行通讯队列的初始化
- 使用`app.communication.cloud_skt_client.start_client_communication`方法进行通讯服务的初始化
- 使用`app.utils.communication.communicate`方法进行发送请求包，并使用变量接受服务端返回的信息或者本地错误信息。
## 学生端接口
### 例子
用户登录：
``` python
# coding=utf8
import Queue
import threading
from app.communication.cloud_skt_client import start_client_communication
from app.utils import communication

# 初始化请求队列
request_queue = Queue.Queue(maxsize=5)
# 初始化响应队列
response_queue = Queue.Queue(maxsize=5)
# 通讯服务初始化
# 因为网络通讯服务处于一个while循环中，是阻塞的，所以要开启一个线程，用于开启网络通讯服务。
task = threading.Thread(target=start_client_communication,
                        args=(request_queue, response_queue, '/home/hz/workspace/SIMSystem/config/config_cloud.json'))
task.setDaemon(True)
task.start()
# 初始化通讯组件
communication.init(request_queue, response_queue)
# 进行网络通讯
state, response = communication.communicate({
    'action': 'student_login',
    'info': {
        'user_code': '129',
        'passwd': '129'
    }
})
print "state:{}".format(state)
print "response:{}".format(response)
```
如果登录成功，将会输出类似以下内容
``` text
state:True
response:{
    u'action': u'student_login',
    u'info': {u'status': u'valid', u'passwd': u'129', u'user_type': u'student', u'user_code': u'129',
              u'user_name': u'129', u'id': 1},
    u'state': True, u'signature': u'0.581182742885'
}

```
### 接口规则
所有网络接口的通讯都必须使用`app.utils.communication.communicate`方法。这个方法接受一个`dict`类型的参数并返回一个`dict`类型的结果。其接受的`dict`类型的参数基本结构如下：

``` python
state, result = communication.communicate({
    'action': 'student_login',
    'info': {
        'user_code': '129',
        'passwd': '129'
    }
})
```
- `action`：必须，其表示这次访问的具体行为，如`student_login`
- `info`：非必须，其表示了这次访问需要用到的数据
传入`app.utils.communication.communicate`（下文将以`communicate`指代）方法的参数将不会经过任何加工直接传入服务端的业务逻辑部分，服务端在处理这个数据包时的具体方法如下：
1. 根据字典中`action`所对应的值找到需要执行的方法
2. 将`info`所对应的值传入待执行的方法，之后执行该方法
3. 对该方法执行后的结果进行封装，并返回

服务端核心代码如下：
``` py
# 此为服务端的核心代码
# 1. 根据字典中`action`所对应的值找到需要执行的方法
action_name = request_info['action']
# 2. 将`info`所对应的值传入待执行的方法，之后执行该方法
request_info = request_info['info']
# 3. 对该方法执行后的结果进行封装，并返回
state, response_info = business_tasks[action_name](request_info)
# 注意，此response不是`communicate`方法的返回值，此response会被进一步处理、封装并返回
response = {
            'action': action_name,
			# signature 的处理由communicate进行自动封装，使用该接口不需要关注
            'signature': request_info['signature'],
            'info': response_info,
            'state': state
        }
response_queue.put(response)
```

`communicate`的返回封装代码如下
- 成功
	`return False, {
                'info': {
                    'detail': error_info
                }
            }`
- 失败
	`return True, response`
	这里的`response`就是服务端的`response`


现有接口如下，其数据包结构将会在下文详细展开。
``` python
business_tasks = {
	# 学生登录时检测mac地址接口
    'student_mac_check': LicenseController.auth,
	# 学生登录接口
    'student_login': StudentController.login,
	# 学生进入课堂接口
    'student_access_course': StudentController.access_course,
	# 学生获取关联车辆接口
    'student_get_vehicle_info': StudentController.get_vehicle_info,
	# 学生绑定车辆接口
    'student_bind_vehicle': StudentController.bind_vehicle,
	# 学生考勤接口
    'student_class_attendance_sign_in': StudentController.class_attendance_sign_in,
}
```
#### 验证mac地址接口
**发送包：**

``` py
{
	'action': 'student_mac_check',
	'info': {
		'terminal_mac': terminal_mac
	}
}
```
- `action`：必须，代表验证mac动作
- `info`：必须，包含mac地址
	- `terminal_mac`：必须，进行验证的mac地址

**返回包：**
- 验证mac地址成功：
	``` py
	return True, model_to_dict(licensed_terminal.get())
	```
	`model_to_dict(licensed_terminal.get())`是一条字典类型的[LicensedTerminal-终端信息表表记录数据](http://192.168.10.106:8080/project/3?p=102)
- 验证mac地址失败：
	``` py
	return False, {
				'detail': '未授权的设备'
			}
	```

#### 学生登录接口
**发送包：**
``` py
{
	'action': 'student_login',
	'info': {
		'user_code': self.ui.user_code.text(),
		'passwd': self.ui.password.text()
	}
}
```
- `action`：必须，代表学生登录动作
- `info`：必须，包含学生信息
	- `user_code`：必须，学生登录进行验证的ID
	- `passwd`：必须，学生登录进行验证的密码

**返回包：**
- 验证成功
	`return True, model_to_dict(exist_user)`
	`model_to_dict(exist_user)`是一条字典类型的[ User-用户信息表 记录数据](http://192.168.10.106:8080/project/3?p=106)
- 验证失败
	`return False, {
                'detail': error_info
            }`
#### 学生进入课堂接口
**发送包：**
``` py
{
	'action': 'student_access_course',
	'info': {
		'student_id': self.user_info['user_code']
	}
}
```
- `action`：必须，代表学生进入课堂动作
- `info`：必须，包含学生信息
	- `student_id`：必须，学生ID

**返回包：**
- 验证成功
	`return True, model_to_dict(current_course.get())`
	`model_to_dict(current_course.get())`是一条是一条字典类型的[  CurrentCourse-当前课程信息表记录数据 ](http://192.168.10.106:8080/project/3?p=115)
- 验证失败
	`return False, {
                'detail': error_info
            }`
#### 学生获取关联车辆信息接口
**发送包：**
``` py
{
	'action': 'student_get_vehicle_info',
	'info': {
		'terminal_mac': self.terminal_mac
	}
}
```
- `action`：必须，代表学生获取关联车辆信息动作
- `info`：必须，包含当前设备mac地址
	- `terminal_mac`：必须，当前设备mac地址
	
**返回包：**
- 验证成功
	`return True, model_to_dict(vehicle_info)`
	`model_to_dict(vehicle_info)`是一条是一条字典类型的[ VehicleInfo-车辆信息表记录数据](http://192.168.10.106:8080/project/3?p=100)
- 验证失败
	`return False, {
                'detail': error_info
            }`
#### 学生绑定车辆接口
**发送包：**
``` py
{
	'action': 'student_bind_vehicle',
	'info': {
		'vehicle_id': self.vehicle_info['id'],
		'terminal_mac': self.terminal_mac
	}
}
```
- `action`：必须，代表学生绑定车辆动作
- `info`：必须
	- `terminal_mac`：必须，当前设备mac地址
	- `vehicle_id`：必须，将绑定的车辆id
**返回包：**
``` python
return True, {
            'detail': '成功绑定'
        }
```
此操作将变更表记录：
1. 更新[VehicleInfo表](http://192.168.10.106:8080/project/3?p=100)，将vehicle_id对应的车辆状态变更为“bind”
2. 在[VehicleTermBind表](http://192.168.10.106:8080/project/3?p=103)中插入一条新记录，其中“bind_type”字段的值为“bind”
3. 更新[LicensedTerminal表](http://192.168.10.106:8080/project/3?p=102)，将当前终端的记录的“status”字段值变更为“bind”
#### 学生考勤签到接口
**发送包：**
``` py
{
	'action': 'student_class_attendance_sign_in',
	'info': {
		'class_id': self.course_info['class_id'],
		'course_id': self.course_info['course_id'],
		'course_name': self.course_info['course_name'],
		'teacher_id': self.course_info['teacher_id'],
		'teacher_name': self.course_info['teacher_name'],
		'student_id': self.user_info['user_code'],
		'student_name': self.user_info['user_name'],
		'terminal_id': self.terminal_info['id'],
		'vehicle_id': self.vehicle_info['id'],
		'login_time': self.login_time,
		'logout_time': self.logout_time,
	}
}
```
- `action`：必须，代表学生考勤签到动作
- `info`：必须
	- `class_id`：必须，班级id
	- `course_id`：必须，课程id
	- `course_name`：必须，课程名称
	- `teacher_id`：必须，教师id
	- `teacher_name`：必须，教师名称
	- `student_id`：必须，学生id
	- `student_name`：必须，学生名称
	- `terminal_id`：必须，使用终端id
	- `vehicle_id`：必须，使用车辆id
	- `login_time`：必须，登录时间

**返回包：**
``` py
return True, {
            'detail': '签到成功'
        }
```
在[ClassAttendance表](http://192.168.10.106:8080/project/3?p=116)插入新记录